static void ScanAndPatchProcessMemory(IntPtr processHandle, byte[] pattern, uint patternSize)
{
    IntPtr currentAddress = IntPtr.Zero;
    MEMORY_BASIC_INFORMATION memInfo;
    uint mbiSize = (uint)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION));
    const int bufferSize = 0x10000; // Read in 64KB chunks
    const int overlapSize = (int)patternSize - 1; // Overlap to handle patterns spanning chunks

    // Loop through the entire address space
    while (VirtualQueryEx(processHandle, currentAddress, out memInfo, mbiSize) != 0)
    {
        // Check if the memory region is committed and readable
        if (memInfo.State == 0x1000 /* MEM_COMMIT */ && (memInfo.Protect & 0xF0) != 0)
        {
            ulong regionBase = (ulong)memInfo.BaseAddress;
            ulong regionSize = (ulong)memInfo.RegionSize;
            ulong regionEnd = regionBase + regionSize;

            // Read the memory region in smaller chunks
            for (ulong address = regionBase; address < regionEnd; address += (ulong)(bufferSize - overlapSize))
            {
                uint bytesToRead = (uint)Math.Min(bufferSize, regionEnd - address);
                byte[] buffer = new byte[bytesToRead];
                uint bytesRead = 0; // Declare bytesRead separately

                try
                {
                    if (ReadProcessMemory(processHandle, (IntPtr)address, buffer, bytesToRead, out bytesRead))
                    {
                        // Search for the pattern in the buffer
                        ulong matchOffset = SearchPattern(buffer, bytesRead, pattern, patternSize);
                        if (matchOffset != 0)
                        {
                            ulong patchAddress = address + matchOffset;
                            Console.WriteLine("Pattern found at address: 0x{0:X}", patchAddress);

                            // Apply the patch
                            uint bytesWritten;
                            if (!WriteProcessMemory(processHandle, (IntPtr)patchAddress, patch, (uint)patch.Length, out bytesWritten))
                            {
                                Console.WriteLine("Failed to write process memory. Error: {0}", Marshal.GetLastWin32Error());
                            }
                            else
                            {
                                Console.WriteLine("Memory patched successfully at address: 0x{0:X}", patchAddress);
                            }

                            // Optionally, you can decide to stop after the first patch
                            // return;
                        }
                    }
                    else
                    {
                        // Handle read errors (optional)
                        int error = Marshal.GetLastWin32Error();
                        Console.WriteLine("Failed to read memory at address 0x{0:X}. Error: {1}", address, error);
                    }
                }
                catch (Exception ex)
                {
                    // Handle any exceptions
                    Console.WriteLine("Exception while reading memory at address 0x{0:X}: {1}", address, ex.Message);
                }
            }
        }

        // Move to the next memory region
        currentAddress = IntPtr.Add(memInfo.BaseAddress, (int)memInfo.RegionSize);
    }
}
