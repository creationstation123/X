using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
public struct MEMORY_BASIC_INFORMATION
{
    public IntPtr BaseAddress;
    public IntPtr AllocationBase;
    public uint AllocationProtect;
    public IntPtr RegionSize;
    public uint State;
    public uint Protect;
    public uint Type;
}

class Program
{
    // Import necessary functions
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint dwSize, out uint lpNumberOfBytesRead);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, uint dwLength);

    const uint PROCESS_VM_READ = 0x0010;
    const uint PROCESS_QUERY_INFORMATION = 0x0400;

    static void Main(string[] args)
    {
        int targetPid = 1234; // Example target process ID (replace with actual)
        byte[] pattern = { 0x48, 0x00, 0x00, 0x74, 0x00, 0x48, 0x00, 0x00, 0x74 };
        uint patternSize = (uint)pattern.Length;

        IntPtr processHandle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, targetPid);
        if (processHandle == IntPtr.Zero)
        {
            Console.WriteLine("Failed to open process. Error: " + Marshal.GetLastWin32Error());
            return;
        }

        // Read the process memory
        ReadProcessMemoryAndSearch(processHandle, pattern, patternSize);
    }

    static void ReadProcessMemoryAndSearch(IntPtr processHandle, byte[] pattern, uint patternSize)
    {
        IntPtr currentAddress = IntPtr.Zero;
        MEMORY_BASIC_INFORMATION memInfo = new MEMORY_BASIC_INFORMATION();
        uint mbiSize = (uint)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION));

        // Iterate through the process memory regions
        while (VirtualQueryEx(processHandle, currentAddress, out memInfo, mbiSize) != 0)
        {
            // Check if the region is committed and readable
            if (memInfo.State == 0x1000 /* MEM_COMMIT */ && (memInfo.Protect & 0xF0) != 0)
            {
                byte[] buffer = new byte[(int)memInfo.RegionSize];

                // Try to read the memory region
                if (ReadProcessMemory(processHandle, memInfo.BaseAddress, buffer, (uint)buffer.Length, out uint bytesRead))
                {
                    Console.WriteLine($"Reading memory at: 0x{memInfo.BaseAddress.ToString("X")} - Size: {memInfo.RegionSize}");

                    // Search for the pattern in the memory region
                    if (SearchPattern(buffer, bytesRead, pattern, patternSize))
                    {
                        Console.WriteLine($"Pattern found at: 0x{memInfo.BaseAddress.ToString("X")}");
                    }
                }
                else
                {
                    Console.WriteLine($"Failed to read memory at: 0x{memInfo.BaseAddress.ToString("X")}. Error: " + Marshal.GetLastWin32Error());
                }
            }

            // Move to the next memory region
            currentAddress = IntPtr.Add(memInfo.BaseAddress, (int)memInfo.RegionSize);
        }
    }

    static bool SearchPattern(byte[] buffer, uint bytesRead, byte[] pattern, uint patternSize)
    {
        for (int i = 0; i <= bytesRead - patternSize; i++)
        {
            bool found = true;
            for (int j = 0; j < patternSize; j++)
            {
                if (buffer[i + j] != pattern[j])
                {
                    found = false;
                    break;
                }
            }

            if (found)
                return true;
        }

        return false;
    }
}
